# 11.2 메모리 동적 할당 및 관리

malloc()과 free() 함수는 메모리를 동적으로 할당 및 해제하는 함수이다. 지금까지 선언했던 변수들은 선어놔 정의로 메모리를 사용했다. 이와 같은 방법의 변수는 자동변수라고 부른다.  
그러나 메모리의 동적 할당 및 해제는 다르다. 이는 **책임이 따르는 메모리 사용방법**이다. 

malloc() 함수를 이용하면 자동변수로 사용할 수 있는 메모리와는 비교할 수 없을 만큼 큰 메모리를 자유로이 다룰 수 있다. 게다가 **동적**으로 다룰 수 있다. 즉, 프로그램 실행중에 메모리가 필요해도 코드의 수정 없이 할당이 가능하다. 그러나 **반환의 책임**이 따른다.

`void *malloc(size_t size);`

**인자** | size : 할당받을 메모리의 바이트 단위 크기        
**반환값** | 힙 영역에 할당된 메모리 덩어리 중 첫 번째 바이트 메모리의 주소. 에러가 발생하면 NULL 반환    
**설명** | 할당받은 메모리는 반드시 free() 함수를 이용하여 반환해야 하며, 메모리를 초기화하려면 memset() 함수를 이용해야 한다. 기본적으로는 쓰레기 값이 들어 있다.


`void free(void *memblock);`

**인자** | memblock : 반환할 메모리의 주소   
**반환값** | 없음   
**설명** | 동적으로 할당받은 메모리를 운영체제에 반환하는 함수

malloc() 함수는 인수로 전달받은 정수만큼의 바이트 단위 메모리를 동적으로 할당하고 주소를 반환한다.
이 주소는 할당받은 메모리 전체에 대한 기준주소이다. 즉, 이 주소를 따라 나머지에 접근할 수 있다.

사용이 끝난 다음에는 반드시 free() 함수를 이용해 메모리를 운영체제에 반환해야 한다. 
free() 함수의 인수로는 malloc() 함수가 반환한 기준주소를 명시해야 한다.

```C
#include <stdio.h>
#include <stdlib.h>
int main(void){
    int *plist = NULL;
    
    //12바이트 메모리를 동적할당하고 시작 주소를 plsts에 저장.
    plist = (int*)malloc(sizeof(int)*3);
    free(plist);
    
    return 1;
}
```

malloc() 함수의 반환 자료형은 void*인데, 어떻게 int*로 받았을까.
바로 강제 형변환이 일어난 것이다. void는 길이도 해석방법도 없다는 의미이다. 
즉, **포인터인 것은 맞지만, 이 주소가 가리키는 대상 메모리를 어떤 형식으로 해석할지는 아직 결정되지 않은 것이다.**

만일 free(plist);를 주석으로 처리하면 심각한 오류가 된다. 개발자의 실수로 메모리가 사용할 수 없는 상태가 되는 것을 메모리 누수라고 한다.

## 11.2.1 메모리 초기화 및 사용(배열)

변수를 선언하면 즉시 0으로 초기화하는 것이 일반적이다. 메모리는 운영체제로부터 빌려오는 것으로, 그 안에 어떤 정보가 있는지는 알 수 없다.
즉, 메모리는 0으로 초기화 하는 것이 바람직하다.

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(void){
    int *plist = NULL, *pnewlist = NULL;
    
    //A. int형 3개 배열 선언 및 정의(0 초기화)
    int alist[3] = { 0 };
    
    //B. int형 3개를 담을 수 있는 크기의 메모리를 동적으로
    //할당한 후 메모리를 모두 0으로 초기화
    plist = (int*)malloc(sizeof(int)*3);
    memset(plist, 0, sizeof(int)*3);
    
    //C. int형 3개를 담을 수 있는 메모리를 0으로 초기화
    //한 후, 할당받음
    pnewlist = (int*)calloc(3, sizeof(int));
    
    free(plist);
    free(pnewlist);
    
    return 1;
}
```

A는 배열 선언 및 정의(0 초기화), B는 malloc() 함수로 동적 할당받은 후, memset() 함수로 0으로 초기화,
C는 calloc() 함수를 이용하여 0으로 초기화한 메모리를 동적 할당한 것이다.

`void *memset(void *dest, int c, size_t count);`
   
인자 | dest : 초기화할 대상 메모리 주소.   
인자 | c : 초깃값. 이 값이 0이면 메모리를 0으로 초기화..   
인자 | count : 초기화 대상 메모리의 바이트 단위 크기   
반환값 | 대상 메모리 주소   
설명 | 동적으로 할당받은 메모리에 쓰레기 값이 있으므로 0으로 초기화해 사용함.

`void *calloc(size_t num, size_t size);`

인자 | num : 요소의 개수   
인자 | size : 각 요소의 바이트 단위 크기   
반환값 | 힙 영역에 할당된 메모리 덩어리 중 첫 번째 바이트 메모리의 주소. 할당된 메모리의 크기는 num 인자와 size 인자의 값을 곱한 크기. 에러가 발생하면 NULL 비교.
설명 | 이 함수는 malloc() 함수와 달리 할당받은 메모리를 0으로 초기화하여 전달한다.
할당받은 메모리는 반드시 free() 함수를 이용하여 반환해야 한다.

calloc()함수는 malloc() 함수와 달리 동적 할당할 메모리의 바이트 단위 크기만 인수로 받는 것이 아니라 마치 배열 선언처럼 요소의 크기와 개수를 각각 받는다. 

`sizeof(int) * 3`이라고 쓰면, 동적 할당한 메모리가 int[3]의 형식으로 사용될 가능성을 암시할 수 있다.

## 11.2.2 메모리 복사

단순 대입 연산자는 오른쪽 r-value의 정보를 왼쪽 피연산자인 l-value에 복사한다.
이 과정에서 l-value의 기존 정보는 유실되고 새 정보로 덮어쓴다. 
이때, l-value가 변수일 경우, 그 인스턴스의 개수가 1개라고 전제한다.
배열처럼 여러 인스턴스는 단순 대입으로 복사할 수 없다.

각 배열의 요소만큼 반복문을 수행하여 요소별로 일일이 단순 대입 연산을 수행 해야 한다.
그러나 memcpy() 함수를 이용하면, 귀찮은 반복을 함수가 대신해준다.

`void *memcpy(void *dest, const void *src, size_t count);`

인자 | dest  : 대상 메모리 주소.  
인자 | src : 복사할 원본 데이터가 저장된 메모리 주소  
인자 | count : 복사할 메모리의 바이트 단위 크기  
반환값 | 대상 메모리 주소.
설명 | 특정 주소로 시작하는 일정 길이의 메모리에 저장된 값을 대상 메모리에 그대로 복사한다.

## 11.2.3 메모리 비교(memcmp(), strcmp())

`int memcmp(const void *buf1, const void *buf2, size_t count);`
  
인자 | buf1 : 비교 원본 메모리 주소  
인자 | buf2 : 비교 대상 메모리 주소  
인자 | count : 비교할 메모리의 바이트 단위 크기  
반환값 | 결과가 0이면 두 값은 같음. 0보다 크면 buf1이 buf2보다 더 큼. 0보다 작으면, buf2가 buf1보다 더 큼.
단, 뺄셈 연산을 수행할 때 unsigned char 형으로 처리. 따라서 -1은 255로 처리.  
설명 | 첫 번째 인자로 전달된 주소의 메모리에 저장된 값에서 두 번째 인자로 전달된 주소에 저장된 메모리의 값을 빼서 두 값이 같은지 비교한다.
즉, 주어진 길이만큼 두 메모리를 비교하는 함수이다.
 
memcmp() 함수의 사용법은 memcpy()와 비슷하다. 그러나 memcpy()가 단순 대입이라면,
memcmp()는 상등/부등 연산자이다.

`int strcmp(const char *string1, const char *string2);`

인자 | string1 : 비교할 문자열이 저장된 메모리 주소  
인자 | string2 : 비교할 문자열이 저장된 메모리 주소  
반환값 | 두 문자열이 같다면 0반환. 만일 0보다 큰 수를 반환하면 string1이 string2보다 나중. 0보다 작으면 string2가 나중  
설명 | 대소문자를 식별하여 두 문자열이 같은지 비교하는 함수.

strcmp() 함수는 memcmp() 함수와 매우 유사하나. 비교의 대상이 되는 정보를 '문자열'로 가정하여 처리하다 보니, 
메모리의 길이를 매개변수로 받지 않는다.

## 11.2.4 문자열 검색

`char *strstr(const char *string, const char *strCharSet);`

인자 | string : 검색 대상이 될 문자열이 저장된 메모리 주소  
인자 | strCharSet : 검색할 문자열이 저장된 메모리 주소  
반환값 | 문자열을 찾으면 해당 문자열이 저장된 메모리 주소 반환. 찾지 못하면 NULL 반환.  
설명 | 임의의 대상 문자열에서 특정 문자열을 검색하는 함수.

## 11.2.5 배열 연산자 풀어쓰기 

1차원 배열을 포인터 관점으로 설명하면 기준주소에서 일정 인덱스만큼 떨어진 상대주소를 배열요소의 변수로 지정하는 연산이라 할 수 있다.
즉, *(기준주소 + 인덱스)나 기준주소[인덱스]나 같은 의미라는 것이다.

```C
#include <stdio.h>
#include <string.h>
int main(void){
    char szBuffer[32] = { "I am a Cuty Apple" };
    
    printf("%c\n", szBuffer[0]);
    printf("%c\n", *szBuffer);
    printf("%c\n", *(szBuffer + 0));
    
    printf("%s\n", &szBuffer[4]);
    printf("%s\n", &*(szBuffer + 4));
    printf("%s\n", szBuffer + 4);
    
    return 1; 
```

## 11.2.6 realloc(), sprintf() 함수

`void *realloc(void *memblock, size_t size);`  
인자 | memblock : 기존에 동적 할당된 메모리 주소. 만일 이 주소가 NULL이면 malloc() 함수와 동일하게 동작.  
size | 다시 할당받을 메모리의 바이트 단위 크기  
반환값 | 다시 할당된 메모리 덩어리 중 첫 번째 바이트의 메모리 주소. 
만일 다시 할당하는 데 실패하면 NULL 반환. 
이 경우 첫 번째 인자로 전달된 메모리를 수동으로 해제해야 함.  
설명 | 만일 이미 할당된 메모리 영역에서 크기를 조정할 수 있다면, 반환된 주소는 첫 번째 인자로 전달된 주소와 같다.
그러나 불가능하다면 기존의 메모리를 해제하고 새로운 영역에 다시 할당한 후, 새로 할당된 메모리의 주소를 반환한다.

realloc() 함수는 이미 할당된 메모리를 이름처럼 재할당하는 함수이다. 재할당은 기존에 있던 것에 추가를 하는 것이다.

`int sprintf(char *buffer, const char *format [, argument] ...);`  
인자 | buffer : 출력 문자열이 저장될 메모리 주소  
인자 | format : 형식 문자열이 저장될 메모리 주소  
인자 | [, argument] : 형식 문자열에 대응하는 가변 인자들
반환값 | 출력된 문자열이 개수  
설명 | 형식 문자열에 밪추어 특정 메모리에 문자열을 저장하는 함수

sprintf() 함수는 printf() 함수는 거의 흡사하지만, 콘솔 화면에 출력되는 것이 아니라 특정 주소의 메모리에 출력된다.
strcpy() 함수와 유사한 것으로 생각하면 된다. strcpy()와 sprintf() 함수는 모두 보안 결합이 있다.
그래서, strcpy_s(), sprintf_s()를 사용하는 것이 좋다.
(Linux, UNIX | strncpy(), snpritnf())

realloc() 함수는 성공과 실패, 아예 실패의 결과가 나올 수 있다. 
먼저, 기존의 주소가 그대로 반환되면, 성공의 의미이다. 만일 다른 주소가 나온다면, 기존의 주소는 free() 되고, 새롭게 만들어 진 것이다.
아예 실패할 경우, NULL이 반환 될 수 있다. 이때는 첫 번째 인수로 전달된 메모리를 해제해주지도 않는다.


### CutyApple 